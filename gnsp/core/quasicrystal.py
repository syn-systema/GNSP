"""
Quasicrystalline lattice generation for network topology.

Quasicrystals exhibit:
- Long-range order without periodicity
- 5-fold (pentagonal) or 10-fold symmetry
- Golden ratio in their structure
- Optimal packing properties

Used for neuron placement in the SNN to achieve:
- Maximally connected topology
- Natural hierarchical structure
- Efficient information routing

Example:
    >>> from gnsp.core.quasicrystal import penrose_vertices, fibonacci_chain
    >>> vertices = penrose_vertices(100)
    >>> chain = fibonacci_chain(50)
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import List, Optional, Set, Tuple
import numpy as np

from gnsp.constants import PHI, PHI_INV, GOLDEN_ANGLE


@dataclass
class Vertex:
    """A vertex in a quasicrystalline lattice."""
    x: float
    y: float
    index: int = 0

    def distance_to(self, other: Vertex) -> float:
        """Euclidean distance to another vertex."""
        return np.sqrt((self.x - other.x) ** 2 + (self.y - other.y) ** 2)

    def as_tuple(self) -> Tuple[float, float]:
        """Return as (x, y) tuple."""
        return (self.x, self.y)

    def as_array(self) -> np.ndarray:
        """Return as numpy array."""
        return np.array([self.x, self.y])


def fibonacci_chain(n: int, scale: float = 1.0) -> np.ndarray:
    """
    Generate a 1D Fibonacci chain (quasiperiodic sequence).

    The Fibonacci chain is generated by substitution:
    A -> AB, B -> A

    The resulting sequence has L (long) and S (short) segments
    in golden ratio proportion.

    Args:
        n: Number of points
        scale: Scale factor for segment lengths

    Returns:
        1D array of positions along the chain

    Example:
        >>> chain = fibonacci_chain(20)
        >>> len(chain)
        20
    """
    if n <= 0:
        return np.array([])

    # Generate Fibonacci word (substitution system)
    # 0 = A (long), 1 = B (short)
    word = [0]
    while len(word) < n:
        new_word = []
        for c in word:
            if c == 0:  # A -> AB
                new_word.extend([0, 1])
            else:  # B -> A
                new_word.append(0)
        word = new_word

    word = word[:n]

    # Convert to positions
    positions = np.zeros(n)
    long_step = scale * PHI
    short_step = scale

    pos = 0.0
    for i, c in enumerate(word):
        positions[i] = pos
        if c == 0:
            pos += long_step
        else:
            pos += short_step

    return positions


def fibonacci_lattice_2d(
    n: int,
    scale: float = 1.0
) -> np.ndarray:
    """
    Generate 2D Fibonacci lattice points.

    Uses the sunflower/phyllotaxis pattern with golden angle separation.
    This provides optimal 2D packing without clustering.

    Args:
        n: Number of points
        scale: Scale factor

    Returns:
        Array of shape (n, 2) with (x, y) coordinates

    Example:
        >>> lattice = fibonacci_lattice_2d(100)
        >>> lattice.shape
        (100, 2)
    """
    points = np.zeros((n, 2), dtype=np.float64)

    for i in range(n):
        theta = i * GOLDEN_ANGLE
        r = scale * np.sqrt(i)
        points[i, 0] = r * np.cos(theta)
        points[i, 1] = r * np.sin(theta)

    return points


def penrose_vertices(
    n: int,
    scale: float = 1.0,
    iterations: int = 5
) -> np.ndarray:
    """
    Generate vertices of a Penrose tiling.

    Uses the dual grid method (de Bruijn's method) to generate
    vertex positions for a Penrose tiling.

    Args:
        n: Approximate number of vertices desired
        scale: Scale factor
        iterations: Number of refinement iterations

    Returns:
        Array of shape (m, 2) where m is close to n

    Example:
        >>> vertices = penrose_vertices(100)
        >>> vertices.shape[1]
        2
    """
    # Use projection method from 5D to 2D
    # Penrose tiling comes from projection of Z^5 lattice

    # Estimate grid size needed
    grid_size = int(np.sqrt(n) * 1.5)

    vertices_set: Set[Tuple[float, float]] = set()

    # 5 grid orientations (5-fold symmetry)
    angles = [2 * np.pi * k / 5 for k in range(5)]

    # Generate grid intersections
    for i in range(-grid_size, grid_size + 1):
        for j in range(-grid_size, grid_size + 1):
            # Sum of grid line contributions
            x = 0.0
            y = 0.0
            for k, angle in enumerate(angles):
                # Offset for this grid direction
                offset = i * np.cos(angle) + j * np.sin(angle)
                # Contribution to position
                contribution = np.floor(offset + 0.5)
                x += contribution * np.cos(angle)
                y += contribution * np.sin(angle)

            # Scale and add if within bounds
            x *= scale
            y *= scale
            if abs(x) < scale * grid_size and abs(y) < scale * grid_size:
                # Round to avoid floating point duplicates
                vertices_set.add((round(x, 6), round(y, 6)))

    # Convert to array and limit to n points
    vertices_list = list(vertices_set)
    if len(vertices_list) > n:
        # Sort by distance from origin and take closest n
        vertices_list.sort(key=lambda v: v[0] ** 2 + v[1] ** 2)
        vertices_list = vertices_list[:n]

    return np.array(vertices_list, dtype=np.float64)


def ammann_beenker_vertices(
    n: int,
    scale: float = 1.0
) -> np.ndarray:
    """
    Generate vertices of an Ammann-Beenker tiling.

    The Ammann-Beenker tiling has 8-fold symmetry and uses
    sqrt(2) ratio instead of golden ratio. Included for comparison.

    Args:
        n: Approximate number of vertices desired
        scale: Scale factor

    Returns:
        Array of shape (m, 2) where m is close to n
    """
    # Use projection from Z^4 to 2D
    grid_size = int(np.sqrt(n) * 1.5)
    sqrt2 = np.sqrt(2)

    vertices_set: Set[Tuple[float, float]] = set()

    # 4 grid orientations (8-fold symmetry from pairs)
    angles = [k * np.pi / 4 for k in range(4)]

    for i in range(-grid_size, grid_size + 1):
        for j in range(-grid_size, grid_size + 1):
            x = 0.0
            y = 0.0
            for k, angle in enumerate(angles):
                offset = i * np.cos(angle) + j * np.sin(angle) / sqrt2
                contribution = np.floor(offset + 0.5)
                x += contribution * np.cos(angle)
                y += contribution * np.sin(angle)

            x *= scale
            y *= scale
            if abs(x) < scale * grid_size and abs(y) < scale * grid_size:
                vertices_set.add((round(x, 6), round(y, 6)))

    vertices_list = list(vertices_set)
    if len(vertices_list) > n:
        vertices_list.sort(key=lambda v: v[0] ** 2 + v[1] ** 2)
        vertices_list = vertices_list[:n]

    return np.array(vertices_list, dtype=np.float64)


def cut_and_project_1d(
    n: int,
    width: float = 1.0,
    scale: float = 1.0
) -> np.ndarray:
    """
    Generate 1D quasicrystal using cut-and-project method.

    Projects 2D square lattice onto a line with irrational slope (1/phi).
    Points within a strip of given width are projected.

    Args:
        n: Number of points desired
        width: Strip width (larger = more points)
        scale: Scale factor

    Returns:
        1D array of quasicrystal positions
    """
    # Project line has slope 1/phi
    slope = PHI_INV

    positions = []
    search_range = int(n * 2)

    for i in range(-search_range, search_range):
        for j in range(-search_range, search_range):
            # Distance from (i, j) to projection line
            # Line: y = slope * x, or slope*x - y = 0
            dist = abs(slope * i - j) / np.sqrt(slope ** 2 + 1)

            if dist < width / 2:
                # Project onto line
                proj = (i + slope * j) / (1 + slope ** 2)
                positions.append(scale * proj)

    positions = sorted(set(positions))

    # Center and limit
    if len(positions) > n:
        mid = len(positions) // 2
        start = mid - n // 2
        positions = positions[start:start + n]

    return np.array(positions, dtype=np.float64)


def voronoi_neighbors(
    points: np.ndarray,
    max_neighbors: int = 10
) -> List[List[int]]:
    """
    Find Voronoi neighbors for each point.

    Two points are Voronoi neighbors if they share a Voronoi cell edge.

    Args:
        points: Array of shape (n, 2) with point coordinates
        max_neighbors: Maximum neighbors to return per point

    Returns:
        List of neighbor index lists for each point
    """
    from scipy.spatial import Voronoi

    n = len(points)
    if n < 4:
        return [[j for j in range(n) if j != i] for i in range(n)]

    vor = Voronoi(points)
    neighbors: List[Set[int]] = [set() for _ in range(n)]

    for ridge_points in vor.ridge_points:
        p1, p2 = ridge_points
        if 0 <= p1 < n and 0 <= p2 < n:
            neighbors[p1].add(p2)
            neighbors[p2].add(p1)

    # Convert to sorted lists, limited to max_neighbors
    result = []
    for i in range(n):
        nbrs = sorted(neighbors[i])
        if len(nbrs) > max_neighbors:
            # Keep closest neighbors
            dists = [(j, np.linalg.norm(points[j] - points[i])) for j in nbrs]
            dists.sort(key=lambda x: x[1])
            nbrs = [d[0] for d in dists[:max_neighbors]]
        result.append(nbrs)

    return result


def delaunay_neighbors(
    points: np.ndarray,
    max_neighbors: int = 10
) -> List[List[int]]:
    """
    Find Delaunay triangulation neighbors for each point.

    Args:
        points: Array of shape (n, 2) with point coordinates
        max_neighbors: Maximum neighbors to return per point

    Returns:
        List of neighbor index lists for each point
    """
    from scipy.spatial import Delaunay

    n = len(points)
    if n < 3:
        return [[j for j in range(n) if j != i] for i in range(n)]

    tri = Delaunay(points)
    neighbors: List[Set[int]] = [set() for _ in range(n)]

    for simplex in tri.simplices:
        for i in range(3):
            for j in range(i + 1, 3):
                p1, p2 = simplex[i], simplex[j]
                neighbors[p1].add(p2)
                neighbors[p2].add(p1)

    # Convert to sorted lists
    result = []
    for i in range(n):
        nbrs = sorted(neighbors[i])
        if len(nbrs) > max_neighbors:
            dists = [(j, np.linalg.norm(points[j] - points[i])) for j in nbrs]
            dists.sort(key=lambda x: x[1])
            nbrs = [d[0] for d in dists[:max_neighbors]]
        result.append(nbrs)

    return result


def golden_spiral_lattice(
    n: int,
    scale: float = 1.0,
    include_center: bool = True
) -> np.ndarray:
    """
    Generate golden spiral lattice (Vogel's model).

    This is the optimal packing for seeds in a sunflower head.

    Args:
        n: Number of points
        scale: Scale factor
        include_center: Whether to include point at origin

    Returns:
        Array of shape (n, 2)
    """
    points = np.zeros((n, 2), dtype=np.float64)

    for i in range(n):
        if i == 0 and include_center:
            continue

        theta = i * GOLDEN_ANGLE
        r = scale * np.sqrt(i)
        points[i, 0] = r * np.cos(theta)
        points[i, 1] = r * np.sin(theta)

    return points


def spherical_fibonacci_lattice(
    n: int,
    radius: float = 1.0
) -> np.ndarray:
    """
    Generate Fibonacci lattice on a sphere.

    Provides near-optimal uniform coverage of the sphere surface.

    Args:
        n: Number of points
        radius: Sphere radius

    Returns:
        Array of shape (n, 3) with (x, y, z) coordinates
    """
    points = np.zeros((n, 3), dtype=np.float64)

    for i in range(n):
        # Golden angle for azimuth
        theta = 2 * np.pi * i / PHI

        # Uniform distribution for cos(phi)
        cos_phi = 1 - 2 * (i + 0.5) / n
        sin_phi = np.sqrt(1 - cos_phi ** 2)

        points[i, 0] = radius * sin_phi * np.cos(theta)
        points[i, 1] = radius * sin_phi * np.sin(theta)
        points[i, 2] = radius * cos_phi

    return points


def compute_packing_density(
    points: np.ndarray,
    radius: Optional[float] = None
) -> float:
    """
    Compute packing density of a point set.

    Estimates the fraction of space covered by disks centered at points.

    Args:
        points: Array of shape (n, 2)
        radius: Disk radius (defaults to half min nearest-neighbor distance)

    Returns:
        Packing density estimate
    """
    n = len(points)
    if n < 2:
        return 0.0

    # Compute pairwise distances
    dists = np.zeros((n, n))
    for i in range(n):
        for j in range(i + 1, n):
            d = np.linalg.norm(points[i] - points[j])
            dists[i, j] = d
            dists[j, i] = d

    # Find minimum non-zero distance
    np.fill_diagonal(dists, np.inf)
    min_dist = np.min(dists)

    if radius is None:
        radius = min_dist / 2

    # Estimate bounding box area
    x_range = np.max(points[:, 0]) - np.min(points[:, 0])
    y_range = np.max(points[:, 1]) - np.min(points[:, 1])
    bbox_area = x_range * y_range

    if bbox_area == 0:
        return 0.0

    # Total disk area
    disk_area = n * np.pi * radius ** 2

    return min(1.0, disk_area / bbox_area)
